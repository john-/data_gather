#!/usr/bin/perl

use Mojolicious::Lite;
use Mojo::IOLoop;
use Mojo::JSON qw(decode_json);
use Mojo::Util qw(dumper);
use Mojo::Pg;
use Mojo::Pg::PubSub;
use Mojo::JSON qw(decode_json encode_json);

use Statistics::Basic qw(:all);
use Time::HiRes qw( usleep );
use IO::Handle;
use File::Temp;    # names for tts files

my $config = plugin Config => { file => '../config/gather.conf' };

app->plugin('RenderFile');
app->plugin('CORS');
app->plugin('ForkCall');    # used to have swift not block

app->secrets( ['Specfying a secret to make the reminder go away.'] );

#my $pg = Mojo::Pg->new('postgresql://script@/cart');
#my $db = $pg->db;

#my %announce_detail_sub;
my @min_max_values;

get '/self' => sub {
    my $c = shift;

    $c->render( json => { function => 'Misc' } );

# ugh this is nasty but I need to store it here because it does not work in the helper
    app->defaults->{audio_url} = $c->url_for('audio')->to_abs;
};

get '/script' => { template => 'script' };

get '/audio' => sub {
    my $c    = shift;
    my $file = $c->param('file');

    # Open file in browser(do not show save dialog)
    $c->render_file(
        'filepath'            => "../archive/$file",
        'content_disposition' => 'inline'
    );
};

#get '/standings' => sub {
#    my $c = shift;

#    $c->render( json => app->defaults->{field} );
#};

websocket '/output' => sub {
    my $c = shift;

    $c->inactivity_timeout(60);

    my $client =
      $c->tx->remote_address . $c->tx->remote_port;    # unique identifier
        # TODO: delete this on connection close

    $c->send( { json => app->config_msg } );

    #app->defaults->{announce_sub}{$client} = [];

    my $cb = $c->pubsub->listen(sensor_msg => sub {
        my ($pubsub, $payload) = @_;
        my $msg = decode_json($payload);
        $c = $c->send( { json => $msg } );
        app->log->debug("item to let client know about (pubsub): $msg->{type}");
    });

    $c->on(
        json => sub {
            my ( $ws, $hash ) = @_;

            #if ( $hash->{type} eq 'set_series' ) {
            #    app->set_series( $hash->{series} );
            #}
            #elsif ( $hash->{type} eq 'set_rate' ) {
            #    app->set_rate( $hash->{rate} );
            #}

            #app->log->debug("Message: ".dumper($hash));
        }
    );

    $c->on(
        finish => sub {
            my ( $c, $code, $reason ) = @_;
            $c->pubsub->unlisten( sensor_msg => $cb );
            $c->app->log->debug("WebSocket closed ($code)");
        }
    );

};

websocket '/output_detail' => sub {
    my $c = shift;

    $c->inactivity_timeout(30);

    my $client =
      $c->tx->remote_address . $c->tx->remote_port;    # unique identifier
        # TODO: delete this on connection close

    foreach my $input (@min_max_values) {
        $c->send( { json => $input } );
    }
    # send initial values

    #app->log->info("Setting notice to plublish for $client");
    #app->defaults->{announce_detail_sub}{$client} = [];
    #$announce_detail_sub{$client} = [];

    my $cb = $c->pubsub->listen(sensor_detail_msg => sub {
        my ($pubsub, $payload) = @_;
        my $msg = decode_json($payload);
        $c = $c->send( { json => $msg } );
        #app->log->debug("item to let client know about (pubsub/detail)".dumper($msg));
    });

    $c->on(
        json => sub {
            my ( $ws, $hash ) = @_;

            if ( $hash->{type} eq 'close' ) {
		$ws->finish;
            }
        }
    );

    $c->on(
        finish => sub {
            my ( $c, $code, $reason ) = @_;
            $c->pubsub->unlisten( sensor_detail_msg => $cb );
            $c->app->log->debug("WebSocket for details closed ($code) client $client");
        }
    );
};

helper pg => sub {
    state $pg = Mojo::Pg->new('postgresql://script@/cart')
	or app->log->error('Could not connect to database');
};

helper pubsub => sub {
    my $self = shift;

    state $pubsub = Mojo::Pg::PubSub->new(pg => $self->pg);
};


helper config_msg => sub {
    my $self = shift;

    return { type => 'config', %{$config} };
};

#helper get_msg => sub {
#    my ( $self, $client ) = @_;

#    return shift @{ app->defaults->{announce_sub}{$client} };
#};

#helper publish => sub {
#    my ( $self, $msg ) = @_;

#    push @$_, $msg for values %{ app->defaults->{announce_sub} };
#};


#helper get_detail_msg => sub {
#    my ( $self, $client ) = @_;

    #if (!exists $announce_detail_sub{$client}) { return };

    #return shift @{ $announce_detail_sub{$client} };

#    return shift @{ app->defaults->{announce_detail_sub}{$client} };
#};

#helper publish_detail => sub {
#    my ( $self, $msg ) = @_;

    #push @$_, $msg for values %announce_detail_sub;
#    push @$_, $msg for values %{ app->defaults->{announce_detail_sub} };
#};


helper speak => sub {
    my ( $self, $utterance ) = @_;

    app->log->info( sprintf( 'utterance: %s', $utterance ) );

    if ( app->defaults->{tts_count} ge 4 ) {
        app->log->info('tts has been throttled!');
        return
    }

    app->defaults->{tts_count}++;

    my $tmp = File::Temp->new(
        TEMPLATE => 'temp-XXXXX',
        DIR      => '../archive/audio',
        SUFFIX   => '.audio'
	);
    my $filename = $tmp->filename;

    my @args = ( '/opt/swift/bin/swift', '-o', $filename, $utterance );
    $self->fork_call(
        sub {
            my $detail = {
                type => 'audio',

                volume => $config->{volume},
                file   => $filename,

                #start      => time(),
                label => $utterance,
                url   => app->defaults->{audio_url},
            };

            system(@args);
            return $detail;
        },
        sub {
            my ( $c, $detail ) = @_;

	    $c->pubsub->notify(sensor_msg => encode_json( $detail ));
            #app->publish($detail);

            #app->log->info("returned with: " . dumper(@return));
        }
    );

};

my @time = localtime;
my $gps_file = sprintf('../data/%04d%02d%02d-%d.gps', $time[5]+1900, $time[4]+1, $time[3], $$);
open(my $gps_fh, '>', $gps_file)
    or die app->log->error("cannot open $gps_file for output: $!");
$gps_fh->autoflush;

my $id = Mojo::IOLoop->client(
    { port => 2947 } => sub {
        my ( $loop, $err, $stream ) = @_;

        $stream->on(
            read => sub {
                my ( $stream, $bytes ) = @_;

                # Process input
                foreach my $line ( split /\n/, $bytes ) {
                    my $sentence = decode_json($line);

                    #app->log->debug(dumper($sentence));
                    if (( $sentence->{class} eq 'TPV' ) && ( $sentence->{mode} >= 2 )) {
                        $config->{inputs}->{speed}->{value} = $sentence->{speed};

			print $gps_fh $line;
                    }
                }

            }
        );

        # Write request
        $stream->write('?WATCH={"enable":true,"json":true}');

    }
);

foreach my $measures (keys $config->{inputs}) {
    my $input = $config->{inputs}->{$measures};
    if ( $input->{type} =~ /poll/ ) {
        Mojo::IOLoop->recurring(
            $input->{rate} => sub {
                my $loop = shift;

                if ( $input->{type} eq 'poll_1wire' ) {
                    $input->{value} = get_1wire( $input->{file} );
                }
                else {
                    $input->{value} = $input->{calc}
                      ( get_reading( $input->{file}, $input->{iterations} ) );
                }

            }
        );
    }
}

#my $rrd = RRD::Simple->new( file => "../db/cart.rrd" );

Mojo::IOLoop->recurring(
    1 => sub {

        my @updates;
        foreach my $measures (keys $config->{inputs}) {
            my $input = $config->{inputs}->{$measures};
            if ( $input->{value} ) {
                app->log->debug(
                    "update $measures val: $input->{value}");
		my $cur_val = delete $input->{value};
                push @updates, { $measures => $cur_val }; # for rrd update
		app->pubsub->notify(
                    sensor_detail_msg => encode_json( { $measures . '_val' => $cur_val } ));
                #app->publish_detail( { $measures . '_val' => $cur_val } );


		# handle any updates that require tts
		if ($input->{announce} eq 'max') {
		    if ($cur_val >= $input->{max}) {
			$input->{max} = $cur_val;
		    } elsif ($input->{prev_val} == $input->{max}) {
		        my $max_announce =
                            sprintf( 'New maximimum speed of %.2f meters per second', $input->{max} );
			app->log->info($max_announce);
			Mojo::IOLoop->timer(4 => sub { app->speak( $max_announce ) });
                    }
		    $input->{prev_val} = $cur_val;
		} elsif ($input->{announce} =~ /\d+/) {
		    if (abs($input->{prev_val} - $cur_val) >= $input->{announce}) {
			app->log->info(sprintf('need to speak %s changed more than %d',
                                               $measures, $input->{announce}));
			app->speak( sprintf( $input->{phrase}, $cur_val ) );
			$input->{prev_val} = $cur_val;
		    }
		}

            }
        }

	foreach my $row (@updates) {
	    my ($input, $value) = each(%$row);
            app->pg->db->query('insert into sensor_history (input, value) values (?, ?)',
                $input, $value);
        }
    }
);

sub get_1wire {
    my $file = shift(@_);

    open( my $fh, '<', $file ) or die "Can't open $file: $!";
    my @lines = <$fh>;
    close $fh;

    my $raw;
    foreach my $line (@lines) {
        if ( $line =~ /t\=(\d+)/ ) {
            $raw = $1;
        }
    }

    return $raw / 1000;
}

sub get_reading {
    my ( $file, $iterations, $extractor ) = @_;

    my @readings;
    for ( my $i = 1 ; $i <= $iterations ; $i++ ) {
        open( my $fh, '<', $file ) or die "Can't open $file: $!";
        my $read = <$fh>;
        close $fh;
        push @readings, $read;
        usleep(200);    # can't go faster than 125 as /sys is limited to 8kSPS
    }

    #print @readings;
    my $mean = mean( \@readings );

    my $stddev = stddev( \@readings );
    if ( $stddev >= 4.0 ) {

        #    if ( $stddev >= 3.5 ) {
        app->log->debug("out of range std dev: $stddev");

        #$mean = 'U';
    }

    return $mean;
}

helper reset_tts_throttle => sub {
    my $self = shift;

    app->defaults->{tts_count} = 0;

    Mojo::IOLoop->timer( 30 => sub { app->reset_tts_throttle } );
};

sub load_min_max {

    #$db->query('select * from sensor_history')->hashes->map(sub { $_->{input} })->join("\n")->say;
    Mojo::IOLoop->delay(
        sub {
	    my $delay = shift;
	    #$db->query('select * from sensor_history' => $delay->begin);
	    app->pg->db->query('select input, min(value), max(value) from sensor_history where recorded_at > now() - interval \'3 days\' group by input' => $delay->begin);
        },
        sub {
	    my ($delay, $err, $results) = @_;
	    foreach my $item (@{$results->hashes->to_array}) {
		#app->log->debug(dumper($item));
	        #my ($input, $value) = each(%$row);

		push @min_max_values, { $item->{input} . '_min' => $item->{min} };
		push @min_max_values, { $item->{input} . '_max' => $item->{max} }

                #app->publish_detail( { $item->{input} . '_min' => $item->{min} } );
                #app->publish_detail( { $item->{input} . '_max' => $item->{max} } );
	    }
	    #$results->hashes->map(sub { $_->{input} })->join("\n")->say;
        }
    )->wait;
}

app->reset_tts_throttle;

load_min_max;

app->start;

__DATA__

@@ script.html.ep
console.log("Data Gather code running");

var dgather_ws = new WebSocket('<%= url_for('output')->to_abs %>');

setInterval(function () {
        dgather_ws.send(JSON.stringify( { type: "ping" } ));
        }, 45000
);

var dgather_config;
dgather_ws.onmessage = function (event) {
    var msg = $.parseJSON(event.data);

    switch (msg.type) {
        case 'audio':
            enqueue(msg);
            break;
//        case 'update':
//            dgather_page();
//            break;
        case 'config':
            dgather_config = msg;
            //console.log('got the config: ' + dgather_config.inputs.speed.type);
            break;
    }

};

//function injectStyles(rule) {
//  var div = $("<div />", {
//    html: '&shy;<style>' + rule + '</style>'
//  }).appendTo("body");
//}

//injectStyles('.position_improve.ui-btn.ui-btn-icon-right.ui-icon-carat-r { background-color: green; }');
//injectStyles('.position_deprove.ui-btn.ui-btn-icon-right.ui-icon-carat-r { background-color: red; }');
//injectStyles('.status_pit.ui-btn.ui-btn-icon-right.ui-icon-carat-r { background-color: orange; }');

//injectStyles = null;

var dgather_detail_ws;

misc_page = function () {

    // TODO: this is pretty convoluted and better way should be found
    //       Actually, there might not be a need for this.  To be verified. (TODO)
    var active_id = $("#switcher").tabs("option", "active");
    active = $("#switcher ul>li a").eq(active_id).attr('href');

    if (active != '#misc') {
        console.log('Execute data gather cleanup');
        dgather_detail_ws.send(JSON.stringify( { type: "close" } ));
        //dgather_detail_ws.close();
        return
    }

    console.log("Populating data gather page");

    // $('#misc').empty();   // probably need to empty this when leaving the page or don't bother starting over
    $('#misc').empty().append('<div class="ui-grid-c" id="readings"</div>');

    $.each(dgather_config.inputs, function(key, val) {
        //$('#misc').append('<p>' + key + '</p>');

        $('<div class="ui-block-a">').append(
            $('<div>', {
                class: 'ui-bar ui-bar-a',
                text: key,
        })).appendTo('#readings');

        $('<div class="ui-block-b">').append(
            $('<div>', {
                class: 'ui-bar ui-bar-a',
                text: 'value',
                id: key + '_val',
        })).appendTo('#readings');

        $('<div class="ui-block-c">').append(
            $('<div>', {
                class: 'ui-bar ui-bar-a',
                text: 'min',
                id: key + '_min',
        })).appendTo('#readings');

        $('<div class="ui-block-d">').append(
            $('<div>', {
                class: 'ui-bar ui-bar-a',
                text: 'max',
                id: key + '_max',
        })).appendTo('#readings');
    });

    dgather_detail_ws = new WebSocket('<%= url_for('output_detail')->to_abs %>');

    dgather_detail_ws.onmessage = function (event) {
        var msg = $.parseJSON(event.data);

        var measures = Object.keys(msg)[0];
        $('#' + measures).text(msg[measures]);
    }

};

misc_config = function() {

    // approach from: http://stackoverflow.com/questions/16015810/jquery-mobile-best-way-to-create-pop-up-and-content-dynamically

    var $config = $("<div/>").popup({
        theme : "a",
        overlyaTheme : "a",
        transition : "pop"
    }).on("popupafterclose", function() {
        //remove the popup when closing
        $(this).remove();
    });

    $("<h2/>", {
        text : "Data Gather Configuration"
    }).appendTo($config);

    //Create a submit button(fake)
    $("<a>", {
        text : "OK"
    }).buttonMarkup({
        inline : true,
        icon : "check"
    }).bind("click", function() {
        $config.popup("close");
        check_for_dgather_changes();
        //that.subscribeToAsset(callback);
    }).appendTo($config);

    //create a back button
    $("<a>", {
        text : "Cancel",
    }).buttonMarkup({
        inline : true,
        icon : "back"
    }).bind('click', function() {
        $config.popup('close');
    }).appendTo($config);

    $config.popup("open").trigger("create");
};

check_for_dgather_changes = function() {

//    if ( $('#rate').val() != lboard_config.rate ) {
//        lboard_ws.send(JSON.stringify( { type: "set_rate", rate: $('#rate').val() } ));             }
//    if ( $('#lboards').val() != lboard_config.series ) {
//        lboard_ws.send(JSON.stringify( { type: "set_series", series: $('#lboards').val() } ));    }

};
